cmake_minimum_required(VERSION 3.30)

# Only define the project if not included as a subdirectory, this is important
# because it won't work if included as a subdirectory from a game project
# otherwise.

# set a variable to check if the project is included as a subdirectory the value
# for the variable should be `CMAKE_CURRENT_SOURCE_DIR STREQUAL
if(${CMAKE_CURRENT_SOURCE_DIR} STREQUAL ${CMAKE_SOURCE_DIR})
  set(BUILDING_ONLY_ATLAS ON)
  message(STATUS "Building Atlas as a standalone project.")
else()
  set(BUILDING_ONLY_ATLAS OFF)
endif()

if(BUILDING_ONLY_ATLAS)
  project(atlas)
endif()

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

add_library(atlas STATIC)
add_library(atlas::atlas ALIAS atlas)
include(SetupModules.cmake SetupExternalLibraries.cmake)

target_include_directories(${PROJECT_NAME} PUBLIC include)
add_subdirectory(include)
add_subdirectory(src)

option(BUILD_TESTS "Build tests" ON)
if(BUILDING_ONLY_ATLAS AND BUILD_TESTS)
  message(STATUS "Building tests.")
  include(CTest)
  add_subdirectory(tests)
else()
  message(STATUS "Skipping tests.")
endif()

# This is false by default, it doesnt make any sense to install this lib on our
# system. This is only used by nix when using the flake.
if(ENABLE_INSTALL AND BUILDING_ONLY_ATLAS)
  install(TARGETS atlas DESTINATION lib)
endif()

# Workaround for libraries that use modmap and need to work with clangd. This is
# only necessary until llvm version 20 where support for modmap is added to
# clangd.
set(ALL_SYSTEM_INCLUDE_DIRS "")

find_package(glm REQUIRED)
if(TARGET glm::glm-header-only)
  get_target_property(LIB_INC glm::glm-header-only
                      INTERFACE_INCLUDE_DIRECTORIES)
  if(LIB_INC)
    list(APPEND ALL_SYSTEM_INCLUDE_DIRS ${LIB_INC})
    message(STATUS "Found GLM includes for
.clangd: ${LIB_INC}")
  endif()
  unset(LIB_INC)
else()
  message(WARNING "Target
'glm::glm-header-only' (or GLM_INCLUDE_DIRS variable) not found for .clangd
generation.")
endif()

find_package(glfw3 3.4 REQUIRED)
if(TARGET glfw)
  get_target_property(LIB_INC glfw INTERFACE_INCLUDE_DIRECTORIES)
  if(LIB_INC)
    list(APPEND ALL_SYSTEM_INCLUDE_DIRS ${LIB_INC})
    message(STATUS "Found GLFW includes for .clangd: ${LIB_INC}")
  endif()
  unset(LIB_INC) # Clean up variable
else()
  message(WARNING "Target 'glfw' not found for .clangd generation.")
endif()

# --- Generate the .clangd content ---
set(CLANGD_CONTENT "CompileFlags:\n") # Start the YAML structure
string(APPEND CLANGD_CONTENT "  # Generated by CMakeLists.txt\n")
string(APPEND CLANGD_CONTENT "  Add:\n") # Start the list of flags to add

if(ALL_SYSTEM_INCLUDE_DIRS)
  # Remove duplicate paths that might have been added
  list(REMOVE_DUPLICATES ALL_SYSTEM_INCLUDE_DIRS)
  message(
    STATUS "Unique system includes for .clangd: ${ALL_SYSTEM_INCLUDE_DIRS}")

  # Add each unique include directory as an -isystem flag The format "-
  # -isystem\n - /path/to/include" adds two arguments per include path
  foreach(INCLUDE_DIR ${ALL_SYSTEM_INCLUDE_DIRS})
    # Use -isystem for system libraries to suppress warnings from them
    string(APPEND CLANGD_CONTENT "    - -isystem\n") # The flag itself
    string(APPEND CLANGD_CONTENT "    - ${INCLUDE_DIR}\n") # The path, ensure
                                                           # it's quoted if
                                                           # needed (usually not
                                                           # for clangd yaml)
  endforeach()
else()
  string(APPEND CLANGD_CONTENT
         "    # No system include directories found by CMake script\n")
endif()

file(WRITE ${CMAKE_SOURCE_DIR}/.clangd "${CLANGD_CONTENT}")
message(STATUS "Generated/Updated .clangd in ${CMAKE_SOURCE_DIR}")
